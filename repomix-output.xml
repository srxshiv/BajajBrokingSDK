This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  config/
    logger.ts
    swagger.ts
  controllers/
    tradeController.ts
  model/
    store.ts
  routes/
    api.ts
  sdk/
    BajajBrokingSDK.ts
  types/
    index.ts
  app.ts
  demo.ts
package.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/config/logger.ts">
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.Console({
      format: winston.format.simple(),
    }),
  ],
});
</file>

<file path="src/config/swagger.ts">
import swaggerUi from 'swagger-ui-express';
import { Express } from 'express';

const swaggerDocument = {
  openapi: '3.0.0',
  info: {
    title: 'Bajaj Broking Assignment API',
    version: '1.0.0',
    description: 'Trading SDK Wrapper Assignment',
  },
  servers: [
    { url: 'http://localhost:3000/api/v1', description: 'Local Development Server' }
  ],
  paths: {
    '/instruments': {
      get: {
        summary: 'Get all tradable instruments',
        responses: { '200': { description: 'List of instruments' } }
      }
    },
    '/orders': {
      post: {
        summary: 'Place a new order',
        requestBody: {
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  symbol: { type: 'string', example: 'RELIANCE' },
                  type: { type: 'string', enum: ['BUY', 'SELL'] },
                  style: { type: 'string', enum: ['MARKET', 'LIMIT'] },
                  quantity: { type: 'number', example: 10 },
                  price: { type: 'number', example: 2500 }
                }
              }
            }
          }
        },
        responses: { '201': { description: 'Order Created' } }
      }
    },
    '/portfolio': {
      get: {
        summary: 'Get User Portfolio & Cash',
        responses: { '200': { description: 'Portfolio data' } }
      }
    }
  }
};

export const setupSwagger = (app: Express) => {
  app.use('/docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));
  console.log('üìÑ Swagger Docs available at http://localhost:3000/docs');
};
</file>

<file path="src/controllers/tradeController.ts">
// src/controllers/tradeController.ts (Updated)

import { Request, Response } from 'express';
import { db } from '../model/store';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '../config/logger';
import { Order, PortfolioPosition } from '../types';

export const getInstruments = (req: Request, res: Response) => {
  console.log("request aayi")
  res.json(db.instruments);
};

export const placeOrder = (req: Request, res: Response) => {
  // 1. Extract Data
  const { symbol, type, style, quantity, price } = req.body;

  // 2. Validate Inputs
  if (!quantity || quantity <= 0) {
    return res.status(400).json({ error: "Quantity must be greater than 0" });
  }

  const instrument = db.instruments.find(i => i.symbol === symbol);
  if (!instrument) {
    return res.status(404).json({ error: "Instrument not found" });
  }

  // 3. Determine Execution Price
  // MARKET orders execute at current instrument price. LIMIT orders use the user's price.
  const executionPrice = style === 'MARKET' ? instrument.price : price;

  if (!executionPrice) {
    return res.status(400).json({ error: "Price is required for LIMIT orders" });
  }

  // 4. Validate Funds (Simulation Logic)
  const totalCost = executionPrice * quantity;
  if (type === 'BUY') {
    if (db.userCash < totalCost) {
      return res.status(400).json({ 
        error: "Insufficient Funds", 
        details: `Required: ${totalCost}, Available: ${db.userCash}` 
      });
    }
  } else if (type === 'SELL') {
    const currentHolding = db.userPortfolio.get(symbol);
    if (!currentHolding || currentHolding.quantity < quantity) {
      return res.status(400).json({ error: "Insufficient Holdings to Sell" });
    }
  }

  // 5. Create the Order Object
  const newOrder: Order = {
    id: uuidv4(),
    symbol,
    type,
    style,
    quantity,
    price: executionPrice,
    status: style === 'MARKET' ? 'EXECUTED' : 'PLACED', // Market orders execute instantly
    timestamp: new Date()
  };

  // 6. EXECUTION LOGIC (The "Bonus" Part)
  if (newOrder.status === 'EXECUTED') {
    if (type === 'BUY') {
      // Deduct Cash
      db.userCash -= totalCost;

      // Update Portfolio
      const holding = db.userPortfolio.get(symbol);
      if (holding) {
        // Average Price Calculation: (OldCost + NewCost) / TotalQty
        const oldCost = holding.quantity * holding.averagePrice;
        const newTotalQty = holding.quantity + quantity;
        const newAvgPrice = (oldCost + totalCost) / newTotalQty;
        
        holding.quantity = newTotalQty;
        holding.averagePrice = newAvgPrice;
        holding.currentValue = newTotalQty * instrument.price; 
      } else {
        // New Position
        db.userPortfolio.set(symbol, {
          symbol,
          quantity,
          averagePrice: executionPrice,
          currentValue: totalCost
        });
      }
    } else if (type === 'SELL') {
      // Add Cash
      db.userCash += totalCost;

      // Update Portfolio
      const holding = db.userPortfolio.get(symbol)!; // Validated above
      holding.quantity -= quantity;
      
      // If quantity is 0, remove from portfolio
      if (holding.quantity === 0) {
        db.userPortfolio.delete(symbol);
      } else {
        holding.currentValue = holding.quantity * instrument.price;
      }
    }
  }

  // 7. Save and Return
  db.orders.set(newOrder.id, newOrder);
  
  logger.info(`Order Processed: ${newOrder.id} - ${newOrder.status}`);
  
  // Return the order along with remaining cash for better UX
  res.status(201).json({
    order: newOrder,
    message: newOrder.status === 'EXECUTED' ? 'Order Executed Successfully' : 'Order Placed',
    remainingCash: db.userCash
  });
};

export const getPortfolio = (req: Request, res: Response) => {
    // Recalculate current values based on latest market prices
    const portfolioArray = Array.from(db.userPortfolio.values()).map(position => {
        const instrument = db.instruments.find(i => i.symbol === position.symbol);
        if (instrument) {
            position.currentValue = position.quantity * instrument.price;
        }
        return position;
    });

    res.json({
        cash: db.userCash,
        holdings: portfolioArray,
        totalPortfolioValue: portfolioArray.reduce((acc, curr) => acc + curr.currentValue, 0)
    });
};
export const getTrades = (req: Request, res: Response) => {
  // Filter only 'EXECUTED' orders to simulate a "Trade History"
  const trades = Array.from(db.orders.values())
                      .filter(order => order.status === 'EXECUTED')
                      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
  
  res.json(trades);
};
</file>

<file path="src/model/store.ts">
import { Instrument, Order, PortfolioPosition } from "../types";

export const db = {
  instruments: [
    { symbol: 'RELIANCE', name: 'Reliance Industries', type: 'EQUITY', price: 2500 },
    { symbol: 'TCS', name: 'Tata Consultancy Svcs', type: 'EQUITY', price: 3400 },
    { symbol: 'INFY', name: 'Infosys', type: 'EQUITY', price: 1600 },
  ] as Instrument[],
  
  orders: new Map<string, Order>(),
  
  userPortfolio: new Map<string, PortfolioPosition>(),
  userCash: 100000 
};
</file>

<file path="src/routes/api.ts">
import { Router } from 'express';
import { getInstruments, placeOrder, getPortfolio,getTrades} from '../controllers/tradeController';

const router = Router();

router.get('/instruments', getInstruments);
router.post('/orders', placeOrder);
router.get('/portfolio', getPortfolio);
router.get('/trades', getTrades);

export default router;
</file>

<file path="src/sdk/BajajBrokingSDK.ts">
import axios, { AxiosInstance, AxiosError } from 'axios';
import { Instrument, Order, PortfolioPosition } from '../types';

export class BajajBrokingSDK {
  private client: AxiosInstance;

  constructor(baseURL: string = 'http://localhost:3000/api/v1') {
    this.client = axios.create({
      baseURL,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }

  /**
   * Fetch all available tradable instruments
   */
  async getInstruments(): Promise<Instrument[]> {
    try {
      const response = await this.client.get<Instrument[]>('/instruments');
      return response.data;
    } catch (error) {
      this.handleError(error);
      return []; // Unreachable due to error throwing
    }
  }

  /**
   * Place a new BUY or SELL order
   */
  async placeOrder(
    symbol: string, 
    type: 'BUY' | 'SELL', 
    quantity: number, 
    style: 'MARKET' | 'LIMIT' = 'MARKET',
    price?: number
  ): Promise<Order> {
    try {
      const payload = { symbol, type, quantity, style, price };
      const response = await this.client.post<{ order: Order, message: string }>('/orders', payload);
      return response.data.order;
    } catch (error) {
      this.handleError(error);
      throw error;
    }
  }

  /**
   * Get the current User Portfolio (Cash + Holdings)
   */
  async getPortfolio(): Promise<{ cash: number, holdings: PortfolioPosition[] }> {
    try {
      const response = await this.client.get('/portfolio');
      return response.data;
    } catch (error) {
      this.handleError(error);
      throw error;
    }
  }

  /**
   * Get the status of a specific Order
   */
  async getOrder(orderId: string): Promise<Order> {
    try {
      const response = await this.client.get<Order>(`/orders/${orderId}`);
      return response.data;
    } catch (error) {
      this.handleError(error);
      throw error;
    }
  }

  /**
   * Internal Error Handler to format API errors nicely
   */
  private handleError(error: any) {
    if (axios.isAxiosError(error)) {
        // 1. Server responded with a status code (4xx, 5xx)
        if (error.response) {
            console.error("Server Error Data:", error.response.data); // Debug log
            const errorMsg = error.response.data?.error || JSON.stringify(error.response.data);
            throw new Error(`SDK Error [${error.response.status}]: ${errorMsg}`);
        } 
        // 2. Request was made but no response (Network Error, Server Down)
        else if (error.request) {
            throw new Error("SDK Error: No response received from server. Is it running?");
        }
    }
    // 3. Something else happened
    throw new Error(`SDK Error: ${error.message}`);}
}
</file>

<file path="src/types/index.ts">
export interface Instrument {
  symbol: string;
  name: string;
  type: 'EQUITY' | 'DERIVATIVE';
  price: number;
}

export interface Order {
  id: string;
  symbol: string;
  type: 'BUY' | 'SELL';
  style: 'MARKET' | 'LIMIT';
  quantity: number;
  price?: number;
  status: 'NEW' | 'PLACED' | 'EXECUTED' | 'CANCELLED';
  timestamp: Date;
}

export interface PortfolioPosition {
  symbol: string;
  quantity: number;
  averagePrice: number;
  currentValue: number;
}
</file>

<file path="src/app.ts">
import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import apiRoutes from './routes/api';
import { logger } from './config/logger';
import { setupSwagger } from './config/swagger';
import { Request, Response, NextFunction } from 'express';

const app =express();
const PORT =3000;

setupSwagger(app);

app.use(cors());
app.use(bodyParser.json());

app.use((req,res,next)=>{
    logger.info(`${req.method} ${req.url}`)
    next();
})

app.use('/api/v1', apiRoutes);

app.use((err: any, req: Request, res: Response, next: NextFunction) => {
  logger.error(`Unhandled Error: ${err.message}`);
  res.status(500).json({
    error: "Internal Server Error",
    requestId: req.headers['x-request-id'] 
  });
});


app.listen(PORT, () => {
  logger.info(`Server running on http://localhost:${PORT}`);
  logger.info(`Swagger Docs available at http://localhost:${PORT}/docs (To be implemented)`);
});
</file>

<file path="src/demo.ts">
import { BajajBrokingSDK } from './sdk/BajajBrokingSDK';

async function main() {
  const sdk = new BajajBrokingSDK();
  
  console.log("üöÄ Starting Trading Simulation...\n");

  try {
    // 1. View Market Data
    console.log("1. Fetching Instruments...");
    const instruments = await sdk.getInstruments();
    console.table(instruments);

    // 2. Check Wallet before trading
    console.log("\n2. Checking Wallet...");
    let portfolio = await sdk.getPortfolio();
    console.log(`üí∞ Cash Balance: ‚Çπ${portfolio.cash}`);

    // 3. Buy RELIANCE (Market Order)
    console.log("\n3. Placing BUY Order for RELIANCE (10 Qty)...");
    const buyOrder = await sdk.placeOrder("RELIANCE", "BUY", 10);
    console.log(`‚úÖ Order Executed! ID: ${buyOrder.id} at Price: ‚Çπ${buyOrder.price}`);

    // 4. Check Wallet again
    portfolio = await sdk.getPortfolio();
    console.log(`üí∞ New Cash Balance: ‚Çπ${portfolio.cash}`);
    console.log("üì¶ Holdings:", portfolio.holdings);

    // 5. Sell Some Shares
    console.log("\n5. Selling 5 RELIANCE shares...");
    const sellOrder = await sdk.placeOrder("RELIANCE", "SELL", 5);
    console.log(`‚úÖ Order Sold! ID: ${sellOrder.id}`);

    // 6. Final Portfolio Check
    portfolio = await sdk.getPortfolio();
    console.table(portfolio.holdings);
    console.log(`üí∞ Final Cash: ‚Çπ${portfolio.cash}`);

  } catch (error: any) {
    console.error("‚ùå Simulation Failed:", error.message);
  }
}

main();
</file>

<file path="package.json">
{
  "name": "shivinternship",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node dist/app.js",
  "dev": "nodemon src/app.ts",
  "build": "tsc"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "axios": "^1.13.2",
    "body-parser": "^2.2.2",
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^13.0.0",
    "winston": "^3.19.0"
  },
  "devDependencies": {
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.6",
    "@types/node": "^25.0.3",
    "@types/swagger-ui-express": "^4.1.8",
    "@types/uuid": "^10.0.0",
    "@types/ws": "^8.18.1",
    "nodemon": "^3.1.11",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",             
    "moduleResolution": "node",       
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
</file>

</files>
